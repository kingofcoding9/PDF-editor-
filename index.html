<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omni-PDF Converter</title>
    
    <!-- 1. Tailwind CSS for Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 950: '#020617' } // Ensure deep dark mode
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    }
                }
            }
        }
    </script>

    <!-- 2. Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- 3. PDF Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Set Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <style>
        /* Custom Utilities */
        body { background-color: #020617; color: #e2e8f0; font-family: sans-serif; overflow: hidden; }
        .canvas-container { box-shadow: 0 0 50px -12px rgba(0, 0, 0, 0.5); transition: transform 0.2s ease-out; }
        
        /* Draggable Element Styles */
        .overlay-element { position: absolute; cursor: move; user-select: none; }
        .overlay-element.selected { outline: 2px solid #06b6d4; outline-offset: 2px; }
        .overlay-element:hover { outline: 1px solid #67e8f9; }
        
        /* Delete Button */
        .delete-btn { 
            position: absolute; top: -12px; right: -12px; 
            background: #ef4444; color: white; border-radius: 50%; 
            width: 20px; height: 20px; display: none; 
            align-items: center; justify-content: center; cursor: pointer; z-index: 50;
        }
        .overlay-element.selected .delete-btn { display: flex; }

        /* Text Area transparency */
        textarea.pdf-input { 
            background: transparent; border: none; outline: none; 
            resize: none; overflow: hidden; width: 100%; height: 100%; 
            color: #0f172a; font-family: sans-serif; line-height: 1.2;
        }
        
        /* Modal Animation */
        .modal { transition: opacity 0.3s ease; opacity: 0; pointer-events: none; }
        .modal.active { opacity: 1; pointer-events: auto; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- UPLOAD SCREEN -->
    <div id="upload-screen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6 text-center">
        <div class="bg-slate-900 p-12 rounded-2xl shadow-2xl border border-slate-800 max-w-lg w-full relative overflow-hidden group">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 via-cyan-500 to-blue-500"></div>
            <div class="w-20 h-20 bg-slate-800 text-cyan-400 rounded-2xl flex items-center justify-center mx-auto mb-6 shadow-inner ring-1 ring-slate-700">
                <i data-lucide="cpu" width="40" height="40"></i>
            </div>
            <h1 class="text-4xl font-bold text-white mb-2 tracking-tight">Omni-PDF <span class="text-cyan-400">Converter</span></h1>
            <p class="text-slate-400 mb-8 font-light">Advanced Document Manipulation System</p>
            
            <button onclick="document.getElementById('file-input').click()" class="w-full bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-500 hover:to-cyan-500 text-white font-semibold py-4 px-6 rounded-lg transition-all flex items-center justify-center gap-2 shadow-lg shadow-cyan-900/20">
                <i data-lucide="upload" width="20"></i> Initialize Document
            </button>
            <input type="file" id="file-input" class="hidden" accept="application/pdf">
            
            <div class="mt-8 pt-6 border-t border-slate-800 flex justify-between text-[10px] uppercase tracking-widest text-slate-500 font-mono">
                <span>Property of Omni-Science</span>
                <span>Architect: king_of_coding</span>
            </div>
        </div>
    </div>

    <!-- APP INTERFACE (Hidden initially) -->
    <div id="app-interface" class="flex flex-col h-full hidden">
        
        <!-- TOOLBAR -->
        <div class="h-16 bg-slate-900 border-b border-slate-800 flex items-center justify-between px-4 z-20 shadow-md shrink-0">
            <div class="flex items-center gap-4">
                <span class="font-bold text-slate-100 flex items-center gap-2 tracking-tight">
                    <div class="w-8 h-8 bg-gradient-to-br from-blue-600 to-cyan-600 rounded flex items-center justify-center text-white shadow-lg shadow-cyan-900/50">
                        <i data-lucide="layers" width="18"></i>
                    </div>
                    Omni-PDF
                </span>
                <div class="h-6 w-px bg-slate-700 mx-2"></div>
                
                <!-- Tools -->
                <button onclick="setTool('select')" id="tool-select" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all bg-slate-800 text-cyan-400 ring-1 ring-cyan-500/50" title="Select">
                    <i data-lucide="move" width="18"></i>
                </button>
                <button onclick="addText()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Add Text">
                    <i data-lucide="type" width="18"></i>
                </button>
                <button onclick="addRect()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Whiteout">
                    <i data-lucide="square" width="18"></i>
                </button>
                <button onclick="document.getElementById('image-input').click()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Add Image">
                    <i data-lucide="image" width="18"></i>
                </button>
                <input type="file" id="image-input" class="hidden" accept="image/*">
                
                <button onclick="openSignatureModal()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Add Signature">
                    <i data-lucide="pen-tool" width="18"></i>
                </button>
            </div>

            <div class="flex items-center gap-4">
                <div class="flex items-center bg-slate-800 rounded-lg p-1 border border-slate-700">
                    <button onclick="updateScale(-0.25)" class="p-1 hover:bg-slate-700 rounded text-slate-400 hover:text-white"><i data-lucide="zoom-out" width="16"></i></button>
                    <span id="zoom-level" class="text-xs font-mono w-12 text-center text-cyan-400">100%</span>
                    <button onclick="updateScale(0.25)" class="p-1 hover:bg-slate-700 rounded text-slate-400 hover:text-white"><i data-lucide="zoom-in" width="16"></i></button>
                </div>
                
                <button onclick="savePdf()" class="bg-cyan-600 hover:bg-cyan-500 text-white px-4 py-2 rounded-lg font-medium flex items-center gap-2 transition-all shadow-lg shadow-cyan-900/40 border border-cyan-500">
                    <i data-lucide="download" width="18"></i> Export
                </button>
            </div>
        </div>

        <!-- WORKSPACE -->
        <div class="flex-1 overflow-auto bg-slate-950 flex justify-center p-8 relative" id="workspace-container">
            <div id="pdf-wrapper" class="relative bg-white shadow-2xl">
                <canvas id="the-canvas" class="block"></canvas>
                <!-- Overlay Container -->
                <div id="overlay-layer" class="absolute inset-0 z-10 overflow-hidden"></div>
            </div>
        </div>

        <!-- FOOTER -->
        <div class="h-14 bg-slate-900 border-t border-slate-800 flex items-center justify-between px-6 z-20 shrink-0">
            <div class="w-1/3 text-xs text-slate-500 font-mono flex gap-4">
                <span class="text-cyan-600/50">SYSTEM: ONLINE</span>
                <span>OWNER: OMNI-SCIENCE</span>
            </div>
            
            <div class="flex items-center justify-center gap-4 w-1/3">
                <button onclick="changePage(-1)" class="text-cyan-400 hover:text-white disabled:opacity-30"><i data-lucide="chevron-left" width="20"></i></button>
                <span class="text-sm font-medium text-slate-300 font-mono">PAGE <span id="page-num" class="text-white">1</span> / <span id="page-count">--</span></span>
                <button onclick="changePage(1)" class="text-cyan-400 hover:text-white disabled:opacity-30"><i data-lucide="chevron-right" width="20"></i></button>
            </div>

            <div class="w-1/3 text-right text-xs text-slate-600 font-mono">
                ARCHITECT: KING_OF_CODING
            </div>
        </div>
    </div>

    <!-- SIGNATURE MODAL -->
    <div id="signature-modal" class="modal fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-slate-900 rounded-xl shadow-2xl border border-slate-700 w-full max-w-md overflow-hidden">
            <div class="p-4 border-b border-slate-800 flex justify-between items-center">
                <h3 class="font-bold text-lg text-slate-200">Initialize Signature</h3>
                <button onclick="closeSignatureModal()" class="text-slate-500 hover:text-slate-300"><i data-lucide="x" width="20"></i></button>
            </div>
            <div class="p-6 bg-slate-950 flex justify-center">
                <canvas id="sig-canvas" width="400" height="200" class="bg-white border-2 border-dashed border-slate-700 rounded-lg cursor-crosshair touch-none"></canvas>
            </div>
            <div class="p-4 bg-slate-900 border-t border-slate-800 flex justify-end gap-2">
                <button onclick="clearSignature()" class="px-4 py-2 text-slate-400 hover:bg-slate-800 rounded-lg text-sm font-medium">Clear Input</button>
                <button onclick="confirmSignature()" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 text-white rounded-lg text-sm font-medium flex items-center gap-2 shadow-lg shadow-cyan-900/40">
                    <i data-lucide="check" width="16"></i> Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // --- State ---
        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let scale = 1.0;
        let canvas = document.getElementById('the-canvas');
        let ctx = canvas.getContext('2d');
        let pdfBytes = null; // Store raw bytes for saving

        // Overlay Elements State
        // Structure: { id, type, x, y, width, height, content, page, fontSize }
        let elements = [];
        let selectedElementId = null;
        let activeTool = 'select'; // select, text, rect, image, signature

        // --- PDF Rendering ---
        function renderPage(num) {
            pageRendering = true;
            
            // Fetch page
            pdfDoc.getPage(num).then(function(page) {
                let viewport = page.getViewport({scale: scale});
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Resize wrapper to match canvas
                document.getElementById('pdf-wrapper').style.width = viewport.width + 'px';
                document.getElementById('pdf-wrapper').style.height = viewport.height + 'px';

                let renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };
                let renderTask = page.render(renderContext);

                // Wait for render to finish
                renderTask.promise.then(function() {
                    pageRendering = false;
                    
                    // Render Overlays for this page
                    renderOverlays();

                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });
            });

            // Update page counters
            document.getElementById('page-num').textContent = num;
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function changePage(offset) {
            if (pageNum + offset >= 1 && pageNum + offset <= pdfDoc.numPages) {
                pageNum += offset;
                queueRenderPage(pageNum);
            }
        }

        function updateScale(delta) {
            let newScale = scale + delta;
            if(newScale >= 0.5 && newScale <= 3.0) {
                scale = newScale;
                document.getElementById('zoom-level').innerText = Math.round(scale * 100) + '%';
                queueRenderPage(pageNum);
            }
        }

        // --- File Handling ---
        document.getElementById('file-input').addEventListener('change', async function(e) {
            let file = e.target.files[0];
            if(file.type !== 'application/pdf') return;

            // Read file
            let arrayBuffer = await file.arrayBuffer();
            pdfBytes = arrayBuffer; // Save for later

            // Load PDF
            pdfjsLib.getDocument(arrayBuffer).promise.then(function(pdfDoc_) {
                pdfDoc = pdfDoc_;
                document.getElementById('page-count').textContent = pdfDoc.numPages;
                
                // Show UI, Hide Upload
                document.getElementById('upload-screen').classList.add('hidden');
                document.getElementById('app-interface').classList.remove('hidden');
                
                renderPage(pageNum);
            });
        });

        document.getElementById('image-input').addEventListener('change', function(e){
            let file = e.target.files[0];
            if(file){
                let reader = new FileReader();
                reader.onload = function(event){
                    let img = new Image();
                    img.onload = function(){
                        // Calc Aspect Ratio
                        let ar = img.width / img.height;
                        let w = 150;
                        let h = 150 / ar;
                        addElement('image', event.target.result, w, h);
                    }
                    img.src = event.target.result;
                }
                reader.readAsDataURL(file);
            }
            // Reset
            e.target.value = '';
        });

        // --- Element Management ---
        function getBaseDimensions() {
            return { w: canvas.width, h: canvas.height };
        }

        function addElement(type, content = '', w = 0, h = 0) {
            const dims = getBaseDimensions();
            const id = Date.now();
            
            let newEl = {
                id: id,
                type: type,
                page: pageNum,
                x: dims.w / 2 - (w || 100) / 2,
                y: dims.h / 2 - (h || 50) / 2,
                width: w,
                height: h,
                content: content,
                viewportWidth: dims.w, // Capture current viewport size for normalization later
                viewportHeight: dims.h,
                fontSize: 16
            };

            if(type === 'text') {
                newEl.width = 200;
                newEl.height = 30;
                newEl.content = "Double click to edit";
            }
            if(type === 'rect') {
                newEl.width = 100;
                newEl.height = 50;
            }

            elements.push(newEl);
            selectedElementId = id;
            setTool('select');
            renderOverlays();
        }

        function addText() { addElement('text'); }
        function addRect() { addElement('rect'); }

        function deleteElement(id) {
            elements = elements.filter(el => el.id !== id);
            renderOverlays();
        }

        function updateElement(id, updates) {
            let idx = elements.findIndex(el => el.id === id);
            if(idx !== -1) {
                elements[idx] = { ...elements[idx], ...updates };
                // Don't full re-render for simple content/pos updates if performance needed, 
                // but for this scale, re-rendering DOM is fine.
            }
        }

        // --- Rendering Overlays (DOM) ---
        function renderOverlays() {
            const container = document.getElementById('overlay-layer');
            container.innerHTML = ''; // Clear

            // Filter for current page
            const pageEls = elements.filter(el => el.page === pageNum);

            pageEls.forEach(el => {
                const div = document.createElement('div');
                div.className = `overlay-element ${selectedElementId === el.id ? 'selected' : ''}`;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = (el.type === 'text' ? 'auto' : el.width + 'px');
                div.style.height = (el.type === 'text' ? 'auto' : el.height + 'px');
                
                // Add Delete Button
                const delBtn = document.createElement('div');
                delBtn.className = 'delete-btn';
                delBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>';
                delBtn.onclick = (e) => { e.stopPropagation(); deleteElement(el.id); };
                div.appendChild(delBtn);

                // Content
                if(el.type === 'text') {
                    const textarea = document.createElement('textarea');
                    textarea.className = 'pdf-input';
                    textarea.value = el.content;
                    textarea.style.fontSize = el.fontSize + 'px';
                    textarea.style.minWidth = '150px';
                    textarea.readOnly = (selectedElementId !== el.id); // Only editable when selected
                    
                    textarea.oninput = (e) => {
                         el.content = e.target.value; 
                         // Auto-expand height
                         e.target.style.height = 'auto';
                         e.target.style.height = e.target.scrollHeight + 'px';
                    };
                    // Handle double click to focus
                    div.ondblclick = (e) => {
                        e.stopPropagation();
                        selectedElementId = el.id;
                        renderOverlays(); // Re-render to enable readonly=false
                        // Determine the newly created textarea in the new DOM
                        // We rely on render sync.
                        // Ideally we'd optimize this, but for now:
                    };
                    div.appendChild(textarea);

                } else if(el.type === 'rect') {
                    div.style.backgroundColor = 'white';
                    div.style.border = '1px solid #ccc';
                } else if(el.type === 'image' || el.type === 'signature') {
                    const img = document.createElement('img');
                    img.src = el.content;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.pointerEvents = 'none';
                    div.appendChild(img);
                }

                // Interaction Events
                div.onmousedown = (e) => startDrag(e, el.id);
                div.onclick = (e) => { e.stopPropagation(); selectedElementId = el.id; renderOverlays(); };

                container.appendChild(div);
            });
        }

        // --- Dragging Logic ---
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let currentDragId = null;

        function startDrag(e, id) {
            e.stopPropagation();
            selectedElementId = id;
            currentDragId = id;
            isDragging = true;
            
            const el = elements.find(x => x.id === id);
            const containerRect = document.getElementById('overlay-layer').getBoundingClientRect();
            
            // Mouse X relative to container - Element X
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;
            
            dragOffset.x = mouseX - el.x;
            dragOffset.y = mouseY - el.y;
            
            renderOverlays(); // To show selection
        }

        window.addEventListener('mousemove', (e) => {
            if(isDragging && currentDragId) {
                const container = document.getElementById('overlay-layer');
                const containerRect = container.getBoundingClientRect();
                
                const mouseX = e.clientX - containerRect.left;
                const mouseY = e.clientY - containerRect.top;
                
                let newX = mouseX - dragOffset.x;
                let newY = mouseY - dragOffset.y;
                
                // Update local model
                let el = elements.find(x => x.id === currentDragId);
                if(el) {
                    el.x = newX;
                    el.y = newY;
                    
                    // Direct DOM update for performance (optional, can just re-render)
                    renderOverlays();
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            currentDragId = null;
        });

        // Deselect on bg click
        document.getElementById('workspace-container').addEventListener('mousedown', (e) => {
            if(e.target.id === 'workspace-container' || e.target.id === 'overlay-layer') {
                selectedElementId = null;
                renderOverlays();
            }
        });

        // --- Tool Selection ---
        function setTool(toolName) {
            activeTool = toolName;
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.className = btn.className.replace(' bg-slate-800 text-cyan-400 ring-1 ring-cyan-500/50', '');
            });
            // Highlight active (simple check based on onclick content or id)
            // For simplicity, just reset classes and let user click work
            // Ideally add IDs to buttons to manage active state class
        }

        // --- PDF Saving ---
        async function savePdf() {
            if(!pdfBytes) return;
            
            const { PDFDocument, rgb, StandardFonts } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfBytes);
            const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const pages = pdfDoc.getPages();

            for (const el of elements) {
                const pageIndex = el.page - 1;
                if(pageIndex >= pages.length) continue;
                
                const page = pages[pageIndex];
                const { width, height } = page.getSize();
                
                // Scale Logic:
                // We rendered the PDF at 'scale'. The DOM elements are positioned based on that scale.
                // We need to map back to PDF Point units.
                
                // Logic: (Element Pos / Viewport Dimension) * PDF Dimension
                const scaleX = width / el.viewportWidth;
                const scaleY = height / el.viewportHeight;
                
                const pdfX = el.x * scaleX;
                // PDF Y is from bottom. 
                // HTML: Top=0. PDF: Bottom=0.
                // We calculate distance from top in PDF units, then subtract from height.
                const elementYFromTop = el.y * scaleY;
                const elementHeightPDF = (el.type === 'text' ? el.fontSize : el.height) * scaleY;
                
                // For text, y is baseline. For images, y is bottom-left usually in pdf-lib drawImage options?
                // pdf-lib drawImage: x,y is bottom-left.
                // pdf-lib drawText: x,y is bottom-left of baseline.
                
                const pdfY = height - elementYFromTop - elementHeightPDF;

                if (el.type === 'text') {
                    page.drawText(el.content, {
                        x: pdfX,
                        y: height - (el.y * scaleY) - (el.fontSize * scaleY), // approx baseline fix
                        size: el.fontSize * scaleY,
                        font: helveticaFont,
                        color: rgb(0, 0, 0),
                    });
                } else if (el.type === 'rect') {
                    page.drawRectangle({
                        x: pdfX,
                        y: height - ((el.y + el.height) * scaleY),
                        width: el.width * scaleX,
                        height: el.height * scaleY,
                        color: rgb(1, 1, 1), // White
                    });
                } else if (el.type === 'image' || el.type === 'signature') {
                     let img;
                     if(el.content.startsWith('data:image/png')) {
                         img = await pdfDoc.embedPng(el.content);
                     } else {
                         img = await pdfDoc.embedJpg(el.content);
                     }
                     
                     page.drawImage(img, {
                         x: pdfX,
                         y: height - ((el.y + el.height) * scaleY),
                         width: el.width * scaleX,
                         height: el.height * scaleY,
                     });
                }
            }

            const pdfBytesSaved = await pdfDoc.save();
            const blob = new Blob([pdfBytesSaved], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'edited_document.pdf';
            link.click();
        }

        // --- Signature Modal ---
        let sigCanvas = document.getElementById('sig-canvas');
        let sigCtx = sigCanvas.getContext('2d');
        let drawingSig = false;

        function openSignatureModal() {
            document.getElementById('signature-modal').classList.add('active');
            // Setup canvas context
            sigCtx.strokeStyle = "#0f172a";
            sigCtx.lineWidth = 2;
            sigCtx.lineCap = 'round';
        }
        function closeSignatureModal() {
            document.getElementById('signature-modal').classList.remove('active');
        }
        function clearSignature() {
            sigCtx.clearRect(0,0, sigCanvas.width, sigCanvas.height);
        }
        function confirmSignature() {
            let data = sigCanvas.toDataURL();
            // Add as signature element
            addElement('signature', data, 150, 80);
            closeSignatureModal();
            clearSignature();
        }

        // Sig Drawing Events
        sigCanvas.addEventListener('mousedown', (e) => {
            drawingSig = true;
            const rect = sigCanvas.getBoundingClientRect();
            sigCtx.beginPath();
            sigCtx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
        });
        sigCanvas.addEventListener('mousemove', (e) => {
            if(!drawingSig) return;
            const rect = sigCanvas.getBoundingClientRect();
            sigCtx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
            sigCtx.stroke();
        });
        window.addEventListener('mouseup', () => { drawingSig = false; });

        // Initialize Icons
        lucide.createIcons();
    </script>
</body>
</html>
