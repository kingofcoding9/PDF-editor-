<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omni-PDF Converter</title>
    
    <!-- 1. Tailwind CSS for Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 950: '#020617' } // Ensure deep dark mode
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    }
                }
            }
        }
    </script>

    <!-- 2. Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- 3. PDF Libraries -->
    <!-- Switched to jsdelivr/pdfjs-dist to fix Worker CORS issues -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // Set Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    </script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <style>
        /* Custom Utilities */
        body { background-color: #020617; color: #e2e8f0; font-family: sans-serif; overflow: hidden; }
        .canvas-container { box-shadow: 0 0 50px -12px rgba(0, 0, 0, 0.5); transition: transform 0.2s ease-out; }
        
        /* Draggable Element Styles */
        .overlay-element { position: absolute; cursor: move; user-select: none; }
        .overlay-element.selected { outline: 2px solid #06b6d4; outline-offset: 2px; }
        .overlay-element:hover { outline: 1px solid #67e8f9; }
        
        /* Properties Toolbar (Floating above element) */
        .props-bar {
            position: absolute; bottom: 100%; left: 0; 
            margin-bottom: 8px; display: none;
            background: #1e293b; border: 1px solid #334155;
            border-radius: 6px; padding: 4px;
            gap: 4px; align-items: center; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.5);
            z-index: 100; white-space: nowrap;
        }
        .overlay-element.selected .props-bar { display: flex; }
        
        /* Resize Handle */
        .resize-handle {
            position: absolute; bottom: -6px; right: -6px;
            width: 12px; height: 12px; background: #06b6d4;
            border: 2px solid #fff; border-radius: 50%;
            cursor: se-resize; display: none; z-index: 50;
        }
        .overlay-element.selected .resize-handle { display: block; }

        /* Text Area transparency */
        textarea.pdf-input { 
            background: transparent; border: none; outline: none; 
            resize: none; overflow: hidden; width: 100%; height: 100%; 
            color: #0f172a; font-family: sans-serif; line-height: 1.2;
        }
        
        /* Modal Animation */
        .modal { transition: opacity 0.3s ease; opacity: 0; pointer-events: none; }
        .modal.active { opacity: 1; pointer-events: auto; }
        
        /* Color Input Reset */
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 24px; height: 24px; cursor: pointer; padding: 0; background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid #475569; border-radius: 4px; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- UPLOAD SCREEN -->
    <div id="upload-screen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6 text-center">
        <div class="bg-slate-900 p-12 rounded-2xl shadow-2xl border border-slate-800 max-w-lg w-full relative overflow-hidden group">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 via-cyan-500 to-blue-500"></div>
            <div class="w-20 h-20 bg-slate-800 text-cyan-400 rounded-2xl flex items-center justify-center mx-auto mb-6 shadow-inner ring-1 ring-slate-700">
                <i data-lucide="cpu" width="40" height="40"></i>
            </div>
            <h1 class="text-4xl font-bold text-white mb-2 tracking-tight">Omni-PDF <span class="text-cyan-400">Converter</span></h1>
            <p class="text-slate-400 mb-8 font-light">Advanced Document Manipulation System</p>
            
            <button onclick="document.getElementById('file-input').click()" class="w-full bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-500 hover:to-cyan-500 text-white font-semibold py-4 px-6 rounded-lg transition-all flex items-center justify-center gap-2 shadow-lg shadow-cyan-900/20">
                <i data-lucide="upload" width="20"></i> Initialize Document
            </button>
            <input type="file" id="file-input" class="hidden" accept="application/pdf">
            
            <div class="mt-8 pt-6 border-t border-slate-800 flex justify-between text-[10px] uppercase tracking-widest text-slate-500 font-mono">
                <span>Property of Omni-Science</span>
                <span>Architect: king_of_coding</span>
            </div>
        </div>
    </div>

    <!-- APP INTERFACE (Hidden initially) -->
    <div id="app-interface" class="flex flex-col h-full hidden">
        
        <!-- TOOLBAR -->
        <div class="h-16 bg-slate-900 border-b border-slate-800 flex items-center justify-between px-4 z-20 shadow-md shrink-0">
            <div class="flex items-center gap-4">
                <span class="font-bold text-slate-100 flex items-center gap-2 tracking-tight">
                    <div class="w-8 h-8 bg-gradient-to-br from-blue-600 to-cyan-600 rounded flex items-center justify-center text-white shadow-lg shadow-cyan-900/50">
                        <i data-lucide="layers" width="18"></i>
                    </div>
                    Omni-PDF
                </span>
                <div class="h-6 w-px bg-slate-700 mx-2"></div>
                
                <!-- Tools -->
                <button onclick="setTool('select')" id="tool-select" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all bg-slate-800 text-cyan-400 ring-1 ring-cyan-500/50" title="Select">
                    <i data-lucide="move" width="18"></i>
                </button>
                <button onclick="addText()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Add Text">
                    <i data-lucide="type" width="18"></i>
                </button>
                <button onclick="addRect()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Whiteout (Rect)">
                    <i data-lucide="square" width="18"></i>
                </button>
                <button onclick="document.getElementById('image-input').click()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Add Image">
                    <i data-lucide="image" width="18"></i>
                </button>
                <input type="file" id="image-input" class="hidden" accept="image/*">
                
                <button onclick="openSignatureModal()" class="tool-btn p-2 rounded-lg text-slate-400 hover:bg-slate-800 hover:text-slate-200 transition-all" title="Add Signature">
                    <i data-lucide="pen-tool" width="18"></i>
                </button>
            </div>

            <div class="flex items-center gap-4">
                <div class="flex items-center bg-slate-800 rounded-lg p-1 border border-slate-700">
                    <button onclick="updateScale(-0.25)" class="p-1 hover:bg-slate-700 rounded text-slate-400 hover:text-white"><i data-lucide="zoom-out" width="16"></i></button>
                    <span id="zoom-level" class="text-xs font-mono w-12 text-center text-cyan-400">100%</span>
                    <button onclick="updateScale(0.25)" class="p-1 hover:bg-slate-700 rounded text-slate-400 hover:text-white"><i data-lucide="zoom-in" width="16"></i></button>
                </div>
                
                <button onclick="savePdf()" class="bg-cyan-600 hover:bg-cyan-500 text-white px-4 py-2 rounded-lg font-medium flex items-center gap-2 transition-all shadow-lg shadow-cyan-900/40 border border-cyan-500">
                    <i data-lucide="download" width="18"></i> Export
                </button>
            </div>
        </div>

        <!-- WORKSPACE -->
        <div class="flex-1 overflow-auto bg-slate-950 flex justify-center p-8 relative" id="workspace-container">
            <div id="pdf-wrapper" class="relative bg-white shadow-2xl">
                <canvas id="the-canvas" class="block"></canvas>
                <!-- Overlay Container -->
                <div id="overlay-layer" class="absolute inset-0 z-10 overflow-hidden"></div>
            </div>
        </div>

        <!-- FOOTER -->
        <div class="h-14 bg-slate-900 border-t border-slate-800 flex items-center justify-between px-6 z-20 shrink-0">
            <div class="w-1/3 text-xs text-slate-500 font-mono flex gap-4">
                <span class="text-cyan-600/50">SYSTEM: ONLINE</span>
                <span>OWNER: OMNI-SCIENCE</span>
            </div>
            
            <div class="flex items-center justify-center gap-4 w-1/3">
                <button onclick="changePage(-1)" class="text-cyan-400 hover:text-white disabled:opacity-30"><i data-lucide="chevron-left" width="20"></i></button>
                <span class="text-sm font-medium text-slate-300 font-mono">PAGE <span id="page-num" class="text-white">1</span> / <span id="page-count">--</span></span>
                <button onclick="changePage(1)" class="text-cyan-400 hover:text-white disabled:opacity-30"><i data-lucide="chevron-right" width="20"></i></button>
            </div>

            <div class="w-1/3 text-right text-xs text-slate-600 font-mono">
                ARCHITECT: KING_OF_CODING
            </div>
        </div>
    </div>

    <!-- SIGNATURE MODAL -->
    <div id="signature-modal" class="modal fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-slate-900 rounded-xl shadow-2xl border border-slate-700 w-full max-w-md overflow-hidden">
            <div class="p-4 border-b border-slate-800 flex justify-between items-center">
                <h3 class="font-bold text-lg text-slate-200">Initialize Signature</h3>
                <button onclick="closeSignatureModal()" class="text-slate-500 hover:text-slate-300"><i data-lucide="x" width="20"></i></button>
            </div>
            <div class="p-6 bg-slate-950 flex justify-center">
                <canvas id="sig-canvas" width="400" height="200" class="bg-white border-2 border-dashed border-slate-700 rounded-lg cursor-crosshair touch-none"></canvas>
            </div>
            <div class="p-4 bg-slate-900 border-t border-slate-800 flex justify-end gap-2">
                <button onclick="clearSignature()" class="px-4 py-2 text-slate-400 hover:bg-slate-800 rounded-lg text-sm font-medium">Clear Input</button>
                <button onclick="confirmSignature()" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 text-white rounded-lg text-sm font-medium flex items-center gap-2 shadow-lg shadow-cyan-900/40">
                    <i data-lucide="check" width="16"></i> Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // --- State ---
        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let scale = 1.0;
        let canvas = document.getElementById('the-canvas');
        let ctx = canvas.getContext('2d');
        let pdfBytes = null; 

        // Overlay Elements State
        // Structure: { id, type, x, y, width, height, content, page, fontSize, color, originalContent }
        let elements = [];
        let selectedElementId = null;
        let activeTool = 'select';

        // --- PDF Rendering ---
        function renderPage(num) {
            pageRendering = true;
            pdfDoc.getPage(num).then(function(page) {
                let viewport = page.getViewport({scale: scale});
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                document.getElementById('pdf-wrapper').style.width = viewport.width + 'px';
                document.getElementById('pdf-wrapper').style.height = viewport.height + 'px';

                let renderContext = { canvasContext: ctx, viewport: viewport };
                let renderTask = page.render(renderContext);

                renderTask.promise.then(function() {
                    pageRendering = false;
                    renderOverlays();
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });
            });
            document.getElementById('page-num').textContent = num;
        }

        function queueRenderPage(num) {
            if (pageRendering) pageNumPending = num;
            else renderPage(num);
        }

        function changePage(offset) {
            if (pageNum + offset >= 1 && pageNum + offset <= pdfDoc.numPages) {
                pageNum += offset;
                queueRenderPage(pageNum);
            }
        }

        function updateScale(delta) {
            let newScale = scale + delta;
            if(newScale >= 0.5 && newScale <= 3.0) {
                scale = newScale;
                document.getElementById('zoom-level').innerText = Math.round(scale * 100) + '%';
                queueRenderPage(pageNum);
            }
        }

        // --- File Handling ---
        document.getElementById('file-input').addEventListener('change', async function(e) {
            let file = e.target.files[0];
            if(file.type !== 'application/pdf') return;
            let arrayBuffer = await file.arrayBuffer();
            pdfBytes = arrayBuffer;
            pdfjsLib.getDocument(arrayBuffer).promise.then(function(pdfDoc_) {
                pdfDoc = pdfDoc_;
                document.getElementById('page-count').textContent = pdfDoc.numPages;
                document.getElementById('upload-screen').classList.add('hidden');
                document.getElementById('app-interface').classList.remove('hidden');
                renderPage(pageNum);
            });
        });

        document.getElementById('image-input').addEventListener('change', function(e){
            let file = e.target.files[0];
            if(file){
                let reader = new FileReader();
                reader.onload = function(event){
                    let img = new Image();
                    img.onload = function(){
                        let ar = img.width / img.height;
                        let w = 150;
                        let h = 150 / ar;
                        addElement('image', event.target.result, w, h);
                    }
                    img.src = event.target.result;
                }
                reader.readAsDataURL(file);
            }
            e.target.value = '';
        });

        // --- Helper: Color Tinting for Signatures ---
        function colorizeImage(dataUrl, color) {
            return new Promise((resolve) => {
                let img = new Image();
                img.onload = () => {
                    let c = document.createElement('canvas');
                    c.width = img.width;
                    c.height = img.height;
                    let ctx = c.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Composite operation to tint non-transparent pixels
                    ctx.globalCompositeOperation = 'source-in';
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, c.width, c.height);
                    
                    resolve(c.toDataURL());
                };
                img.src = dataUrl;
            });
        }

        // --- Element Management ---
        function getBaseDimensions() {
            return { w: canvas.width, h: canvas.height };
        }

        function addElement(type, content = '', w = 0, h = 0) {
            const dims = getBaseDimensions();
            const id = Date.now();
            
            let newEl = {
                id: id,
                type: type,
                page: pageNum,
                x: dims.w / 2 - (w || 100) / 2,
                y: dims.h / 2 - (h || 50) / 2,
                width: w,
                height: h,
                content: content,
                originalContent: content, // Keep original for re-coloring
                viewportWidth: dims.w,
                viewportHeight: dims.h,
                fontSize: 16,
                color: type === 'rect' ? '#ffffff' : '#000000'
            };

            if(type === 'text') {
                newEl.width = 200; newEl.height = 30; newEl.content = "Double click to edit";
            }
            if(type === 'rect') {
                newEl.width = 100; newEl.height = 50;
            }

            elements.push(newEl);
            selectedElementId = id;
            setTool('select');
            renderOverlays();
        }

        function addText() { addElement('text'); }
        function addRect() { addElement('rect'); }

        function deleteElement(id) {
            elements = elements.filter(el => el.id !== id);
            if(selectedElementId === id) selectedElementId = null;
            renderOverlays();
        }

        async function updateElementColor(id, newColor) {
            let idx = elements.findIndex(el => el.id === id);
            if(idx !== -1) {
                let el = elements[idx];
                el.color = newColor;
                
                // If signature, we need to re-process the image data
                if(el.type === 'signature') {
                     // Use original content (black ink) to generate new colored ink
                     let newContent = await colorizeImage(el.originalContent, newColor);
                     el.content = newContent;
                }
                renderOverlays();
            }
        }

        function updateElement(id, updates) {
            let idx = elements.findIndex(el => el.id === id);
            if(idx !== -1) {
                elements[idx] = { ...elements[idx], ...updates };
                // If text content updates, we don't re-render entire DOM to keep focus
            }
        }

        // --- Rendering Overlays (DOM) ---
        function renderOverlays() {
            const container = document.getElementById('overlay-layer');
            container.innerHTML = ''; 

            const pageEls = elements.filter(el => el.page === pageNum);

            pageEls.forEach(el => {
                const div = document.createElement('div');
                div.className = `overlay-element ${selectedElementId === el.id ? 'selected' : ''}`;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = (el.type === 'text' ? 'auto' : el.width + 'px');
                div.style.height = (el.type === 'text' ? 'auto' : el.height + 'px');
                
                // --- Properties Toolbar (Above Element) ---
                if (selectedElementId === el.id) {
                    const propsBar = document.createElement('div');
                    propsBar.className = 'props-bar';
                    
                    // Color Picker (Rect & Signature only)
                    if (el.type === 'rect' || el.type === 'signature') {
                        const colorInput = document.createElement('input');
                        colorInput.type = 'color';
                        colorInput.value = el.color;
                        colorInput.title = "Change Color";
                        colorInput.oninput = (e) => updateElementColor(el.id, e.target.value);
                        // Prevent dragging when clicking color
                        colorInput.onmousedown = (e) => e.stopPropagation(); 
                        propsBar.appendChild(colorInput);
                    }

                    // Delete Button (In toolbar now)
                    const delBtn = document.createElement('button');
                    delBtn.className = 'text-red-400 hover:text-red-300 p-1';
                    delBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>';
                    delBtn.onmousedown = (e) => e.stopPropagation();
                    delBtn.onclick = (e) => { e.stopPropagation(); deleteElement(el.id); };
                    propsBar.appendChild(delBtn);

                    div.appendChild(propsBar);

                    // Resize Handle (Bottom Right) - Not for Text
                    if (el.type !== 'text') {
                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = 'resize-handle';
                        resizeHandle.onmousedown = (e) => startResize(e, el.id);
                        div.appendChild(resizeHandle);
                    }
                }

                // Content
                if(el.type === 'text') {
                    const textarea = document.createElement('textarea');
                    textarea.className = 'pdf-input';
                    textarea.value = el.content;
                    textarea.style.fontSize = el.fontSize + 'px';
                    textarea.style.minWidth = '150px';
                    textarea.readOnly = (selectedElementId !== el.id); 
                    
                    textarea.oninput = (e) => {
                         el.content = e.target.value; 
                         e.target.style.height = 'auto';
                         e.target.style.height = e.target.scrollHeight + 'px';
                    };
                    div.ondblclick = (e) => {
                        e.stopPropagation();
                        selectedElementId = el.id;
                        renderOverlays(); 
                    };
                    div.appendChild(textarea);

                } else if(el.type === 'rect') {
                    div.style.backgroundColor = el.color;
                    div.style.border = '1px solid #ccc';
                } else if(el.type === 'image' || el.type === 'signature') {
                    const img = document.createElement('img');
                    img.src = el.content;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.pointerEvents = 'none';
                    div.appendChild(img);
                }

                // Interaction Events
                div.onmousedown = (e) => startDrag(e, el.id);
                div.onclick = (e) => { e.stopPropagation(); selectedElementId = el.id; renderOverlays(); };

                container.appendChild(div);
            });
        }

        // --- Dragging & Resizing Logic ---
        let isDragging = false;
        let isResizing = false;
        let dragOffset = { x: 0, y: 0 };
        let activeElementId = null;
        let startResizeX, startResizeY, startWidth, startHeight;

        function startDrag(e, id) {
            e.stopPropagation();
            if (isResizing) return; // Don't drag if we hit the resize handle

            selectedElementId = id;
            activeElementId = id;
            isDragging = true;
            
            const el = elements.find(x => x.id === id);
            const containerRect = document.getElementById('overlay-layer').getBoundingClientRect();
            
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;
            
            dragOffset.x = mouseX - el.x;
            dragOffset.y = mouseY - el.y;
            
            renderOverlays(); 
        }

        function startResize(e, id) {
            e.stopPropagation();
            e.preventDefault(); // Prevent text selection
            isResizing = true;
            activeElementId = id;
            
            const el = elements.find(x => x.id === id);
            startResizeX = e.clientX;
            startResizeY = e.clientY;
            startWidth = el.width;
            startHeight = el.height;
        }

        window.addEventListener('mousemove', (e) => {
            if (isDragging && activeElementId) {
                const container = document.getElementById('overlay-layer');
                const containerRect = container.getBoundingClientRect();
                
                const mouseX = e.clientX - containerRect.left;
                const mouseY = e.clientY - containerRect.top;
                
                let newX = mouseX - dragOffset.x;
                let newY = mouseY - dragOffset.y;
                
                let el = elements.find(x => x.id === activeElementId);
                if(el) {
                    el.x = newX;
                    el.y = newY;
                    renderOverlays();
                }
            } else if (isResizing && activeElementId) {
                const deltaX = e.clientX - startResizeX;
                const deltaY = e.clientY - startResizeY;
                
                let el = elements.find(x => x.id === activeElementId);
                if(el) {
                    // Min size check
                    el.width = Math.max(20, startWidth + deltaX);
                    el.height = Math.max(20, startHeight + deltaY);
                    renderOverlays();
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            isResizing = false;
            activeElementId = null;
        });

        document.getElementById('workspace-container').addEventListener('mousedown', (e) => {
            if(e.target.id === 'workspace-container' || e.target.id === 'overlay-layer') {
                selectedElementId = null;
                renderOverlays();
            }
        });

        // --- Tool Selection ---
        function setTool(toolName) {
            activeTool = toolName;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.className = btn.className.replace(' bg-slate-800 text-cyan-400 ring-1 ring-cyan-500/50', '');
            });
        }

        // --- PDF Saving ---
        async function savePdf() {
            if(!pdfBytes) return;
            const { PDFDocument, rgb, StandardFonts } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfBytes);
            const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const pages = pdfDoc.getPages();

            // Helper to parse hex color to RGB (0-1 range)
            const hexToRgb = (hex) => {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16) / 255,
                    g: parseInt(result[2], 16) / 255,
                    b: parseInt(result[3], 16) / 255
                } : { r: 0, g: 0, b: 0 };
            }

            for (const el of elements) {
                const pageIndex = el.page - 1;
                if(pageIndex >= pages.length) continue;
                
                const page = pages[pageIndex];
                const { width, height } = page.getSize();
                
                const scaleX = width / el.viewportWidth;
                const scaleY = height / el.viewportHeight;
                
                const pdfX = el.x * scaleX;
                const elementYFromTop = el.y * scaleY;
                const elementHeightPDF = (el.type === 'text' ? el.fontSize : el.height) * scaleY;
                const pdfY = height - elementYFromTop - elementHeightPDF;

                if (el.type === 'text') {
                    page.drawText(el.content, {
                        x: pdfX,
                        y: height - (el.y * scaleY) - (el.fontSize * scaleY),
                        size: el.fontSize * scaleY,
                        font: helveticaFont,
                        color: rgb(0, 0, 0),
                    });
                } else if (el.type === 'rect') {
                    const c = hexToRgb(el.color);
                    page.drawRectangle({
                        x: pdfX,
                        y: height - ((el.y + el.height) * scaleY),
                        width: el.width * scaleX,
                        height: el.height * scaleY,
                        color: rgb(c.r, c.g, c.b),
                    });
                } else if (el.type === 'image' || el.type === 'signature') {
                     let img;
                     if(el.content.startsWith('data:image/png')) {
                         img = await pdfDoc.embedPng(el.content);
                     } else {
                         img = await pdfDoc.embedJpg(el.content);
                     }
                     page.drawImage(img, {
                         x: pdfX,
                         y: height - ((el.y + el.height) * scaleY),
                         width: el.width * scaleX,
                         height: el.height * scaleY,
                     });
                }
            }

            const pdfBytesSaved = await pdfDoc.save();
            const blob = new Blob([pdfBytesSaved], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'edited_document.pdf';
            link.click();
        }

        // --- Signature Modal ---
        let sigCanvas = document.getElementById('sig-canvas');
        let sigCtx = sigCanvas.getContext('2d');
        let drawingSig = false;

        function openSignatureModal() {
            document.getElementById('signature-modal').classList.add('active');
            sigCtx.strokeStyle = "#000000"; // Always draw black initially, colorize later
            sigCtx.lineWidth = 2;
            sigCtx.lineCap = 'round';
        }
        function closeSignatureModal() {
            document.getElementById('signature-modal').classList.remove('active');
        }
        function clearSignature() {
            sigCtx.clearRect(0,0, sigCanvas.width, sigCanvas.height);
        }
        function confirmSignature() {
            let data = sigCanvas.toDataURL();
            addElement('signature', data, 150, 80);
            closeSignatureModal();
            clearSignature();
        }

        sigCanvas.addEventListener('mousedown', (e) => {
            drawingSig = true;
            const rect = sigCanvas.getBoundingClientRect();
            sigCtx.beginPath();
            sigCtx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
        });
        sigCanvas.addEventListener('mousemove', (e) => {
            if(!drawingSig) return;
            const rect = sigCanvas.getBoundingClientRect();
            sigCtx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
            sigCtx.stroke();
        });
        window.addEventListener('mouseup', () => { drawingSig = false; });

        lucide.createIcons();
    </script>
</body>
</html>
